基本概念：
	程序：是计算机指令的集合，程序是一组静态的指令集，不占用系统运行资源，不能被系统调度，也不能作为独立运行的单位，它以文件的形式存储在磁盘上。

	进程：系统运行程序的基本单位，有独立的内存空间和系统资源，程序运行产生进程，可以是多个进程，进程资源申请、调度
	线程：进程中执行运算的最小单位，进程中包含多个线程，多CPU情况下进行同时调度
		  线程共享其所属进程的内存地址，因此同一个进程中的线程可以访问相同变量，并且从一个堆中共享其所属对象，往往容易出现线程不安全问题。
	并行和并发：
		并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。
	并行和串行：
		并行和串行指的是任务的执行方式。串行是指多个任务时，各个任务按顺序执行，完成一个之后才能进行下一个。
		并行指的是多个任务可以同时执行，异步是多个任务并行的前提条件。

	同步：只有上一件事做完，才会做下一步
	异步：在上一件事，假设在等待，做其他事  例如：烧水等待过程中，看报纸

	线程安全问题？
		User类型
		单例多线程不安全问题，程序运行，至始至终只有一个对象
		多例，认为线程是安全，程序运行中，每一次调用，都会是一个新的对象
		
	线程的生命周期：开始-->结束，有如下一些状态
		新线程：new关键字构建对象，只是作为一个对象实例存在，JVM没有为其分配时间片和其他线程运行资源
		就绪状态：调用start()方法，线程转换成就绪状态。线程获得其他系统资源，等待JVM的线程调度器进行调度，使得该线程获得CPU时间片的机会。
		运行状态：就绪状态的线程获得CPU进入运行状态
		等待/阻塞状态：线程运行过程中被剥夺资源或等待某些事件，进入了等待或阻塞状态。
		死亡状态：线程运行结束或调用stop方法将线程终止运行，JVM收回占用资源。
	
		通过new对象开启一个新线程，调用start()方法，进入就绪状态，获得CPU时间片后，进入运行状态，
			运行过程中可能会发生等待/阻塞，等待事件结束或得到足够资源就会进入就绪状态，获得CPU时间片，又进入运行状态，
			运行结束后，线程进入死亡状态，通知GC进行垃圾回收。


创建与调度：
	构建线程：
		1.继承Thread类，重写run方法，线程启动后执行内容是run方法中的代码
			对Java而言，每一个独立的线程都是一个Thread类的对象
		2.实现Runnable接口，重写run方法，通过构造方法参数值将实现类，传递给Thread类，从而构建线程
		
		Thread类中提供不少的构造方法：
			Thread() 创建一个新的线程
			Thread(String name) 创建一个指定名称的线程
			Thread(Runnable target) 利用Runnable对象创建一个线程，启动时将执行该对象的run方法
			Thread(Runnable target, String name) 利用Runnable对象创建一个线程，并指定该线程的名称
		
		Runnable接口：它只有一个抽象方法，本身又是一个接口，符合使用Lambda表达式要求，注意，它不是一个线程类，它提供run()方法的指令代码，最终还是需要结合Thread类构建线程对象

		main方法它是一个主线程
	线程的启动和停止
		启动线程时，不能直接显示调用run方法，如果显示调用不能产生并发调用的效果，应该使用start();同一个线程，不能多次执行start()方法。
			start()方法调用后并不是立即执行多线程代码，而是使该线程变为就绪状态，什么时候运行由操作系统调度决定。
			
		线程的终止，不建议使用stop方法，因为它本质上是不安全的，该方法已经被废弃；如何终止线程？代码正常运行结束。
			正常情况下，可以通过设置一个标志flag，改变共享变量值的方式让run()方法执行结束。
			如果线程出现阻塞，例如:Thread.sleep()，join(),Obeject提供wait()方法，
				public void interrupt() 可以采用Thread类提供的interrupt()方法，抛出一个异常，捕获异常后，可设置共享flag，来终止线程运行。
				interrupt()方法并不能阻断I/O阻塞或线程同步引起的线程阻塞，也就是说如果有一个线程在等待键盘输入或是等待网络连接等I/O资源，之前的停止方法就会失效
				处理I/O资源引起的线程阻塞时的线程中断问题：
					关闭底层I/O通道，人为引发异常从而进行共享变量重新赋值而跳出线程run()方法。
					使用nio 支持非阻塞式的事件驱动读取操作，在这种模式下不需要关闭底层资源即可通过interrupt（）方法直接中断其等待操作。
		判断线程是否通过interrupt方法被中止
			public static boolean interrupted() 测试当前线程是否中断。 该方法可以清除线程的中断状态 。
			public boolean isInterrupted()	测试这个线程是否被中断。 线程的中断状态不受此方法的影响。


	Java将线程分为两类：用户线程、守护线程
		守护线程：程序运行时，提供一种通用的一些服务的线程；例如：垃圾回收器的线程；守护线程如果没有被守护者（用户线程），守护线程结束；程序运行结束，是用户线程运行结束。
			可以设置线程为守护线程调用Thread类中setDaemon(true),该方法必须在线程启动之前进行设置。
			默认创建的线程是非守护线程。
			不能把正在运行的常规线程设置为守护线程。
			Thread类中还提供isDaemon()方法可以判定线程对象是否是守护线程。
		
	线程中一些重要的方法：
		setName(String name)：给线程设置名称
		getName()；该方法是获取线程名称;用法：线程对象.getName()；Thread.currentThread().getName():获取当前线程的名称
		setPriority(int newPriority)：newPriority数值范围：1-10，设置线程优先级，高优先级线程有更高的几率先执行，优先级高并不是绝对先执行。 
			Thread.MAX_PRIORITY(10)  Thread.MIN_PRIORITY(1)  Thread.NORM_PRIORITY(5);
			新建的线程的优先级如果没有显示指定时就和父线程的优先级保持一致。
			与操作系统与虚拟机有关。
		线程组：线程一个集合，可以将线程加入到线程组当中，线程组中提供了一些有用的方法，
			例如：interrupt():中断线程组中所有的线程；
			线程组中可以设置最大优先级，线程组中的线程的优先级不能超过线程组的优先级，如果超过，将线程组中的线程的优先级调整为线程组的最大优先级。
			在创建的时候可以设置其加入的线程组
			系统线程组的最大优先级默认为Thread.MAX_PRIORITY
			创建线程组的时候其最大优先级默认为父线程组（如果未指定父线程组，则其父线程组默认为当前线程所属线程组）的最大优先级
			可以通过setMaxPriority更改最大优先级，但无法超过父线程组的最大优先级
				问题：	
					该方法只能更改本线程组及其子线程组的最大优先级
					但不能影响已经创建好的直接或者间接属于该线程组的线程的优先级，只能在修改或者创建新的子线程的时候起作用。
					
		sleep() 使当前线程进入被阻塞状态，不会释放资源，使优先级低的线程得到执行的机会。
			阻塞指定时间后，线程转为就绪状态。
			Thread.sleep();
			TimeUnit.SECONDS.sleep(1);
			TimeUnit.MINUTES.sleep(1);
			TimeUnit.HOURS.sleep(1);
			TimeUnit.DAYS.sleep(1);
		yield() 使当前线程重新回到就绪状态，不会释放资源，只能使相同或者更高优先级的线程有执行的机会
			某些时候JVM认为不符合最优资源调度的情况下会忽略该方法的调用
		
		join()方法：当前运行线程可以调用另一个线程的join方法，当前线程就会进入阻塞状态，直到另一个线程结束。
			常用于main()主线程中，等待其他线程执行结束再结束main()主线程，底层源码调用的是Object类的wait()方法。

线程同步：
	线程安全问题：
	线程同步：
		除了保证可见性，防止重排序改变语义之外，还要将该段代码进行原子保护。其主要作用是实现线程安全的类。
		Java中使用synchronized关键字来操作同步处理，一个锁就像一种任何时候只允许一个线程拥有的特权；
		JAVA程序中每一个监视区域都和一个对象引用相关联；
		同步是什么？就是代码按部就班的执行，按顺序执行。
		
	synchronized：
		Java中synchronized关键字获得对象锁，实现线程同步
		synchronized会降低程序的性能
		
		synchronized关键字有两种应用方式：
			1.加载方法之上
				public synchronized void method() {}
				说明：该方法是同步方法，以当前类的对象作为监视器
			2.加载部分代码块：
				synchronized(监视器对象) {
				}
				适当的降低同步整个方法带来的性能消耗。
				
		同一个类中的synchronized方法使用同一个对象的监视器（this）,因此当一个线程获取监视器锁定对象后，其他的线程即使访问的是其它的同步方法，也需要排队等候。
		
		说明：监视器对象，可以是新构建对象new Object()，也可以是this代表当前对象，如果在同一类中，假设有三个方法，它们的监视器对象分别不同，此时三个方法被不同线程调用不同方法，产生并发。

	面试点：死锁？什么是死锁？某个线程A在等待线程B，线程B在等待线程C，线程C在等待线程A，这样一直等下去，直到某个线程打破平衡释放锁，死锁也就被解决了。

线程通讯：为什么要通讯？如果没有线程通讯，有可能出现忙等待，线程A不知道线程B什么时候能给自己想要的，线程A就不断循环轮询共享变量，忙等待不能有效的利用CPU资源，除非平均等待时间非常短。
	线程通信的目标是使线程间能够互相发送信号，另一方面，线程通信也能够等待其它线程的信号。
	volatile :
		保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
　　	禁止进行指令重排序。
	Object类提供的三个方法：wait()、notify()、notifyAll()
	为了调用wait()或者notify(),线程必须先获得那个对象的锁，也就是说，线程必须在同步代码块里调用wait()或者notify()，否则就抛出异常。
		调用wait()方法后进入非运行状态，直到通过notify()或者notifyAll()进行唤醒操作。
		notify()：无法具体指定唤醒哪个线程；notifyAll()：唤醒所有的线程；
		wait方法调用后会释放线程具备的锁。

	
	



	
	
	
	
	
	
	
	
	
	